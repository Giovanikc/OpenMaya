float setRange( float v)
{
   return 0.5 * (1.0 + v);
}
vector planarMapping(vector v)
{
   vector st;
   st[0] = setRange(v[0]);
   st[1] = setRange(v[1]);

   return st;
}

vector sphericalMapping(vector p, float uAngle, float vAngle)
{
   vector st;
   vector v = normalize(p);

   st[0] = setRange(atan2(v[0], v[2]) / uAngle);
   st[1] = setRange(atan2(v[1], sqrt(v[0]*v[0] + v[2]*v[2])) / vAngle);

   return st;
}

vector cylindricalMapping(vector p, float uAngle)
{
   vector st;
   vector v = normalize(p);
   st[0] = setRange(atan2(v[0], v[2]) * 2.0/uAngle);
   st[1] = setRange(v[1]);
   return st;
}

vector ballMapping(vector p)
{
   vector st;
   vector v = normalize(p);
   v[2] += 1.0;
   v = normalize(v);
   st[0] = setRange(v[0]);
   st[1] = setRange(v[1]);
   return st;
}

vector cubicMapping(vector v)
{
   vector st;
   float xAbs = abs(v[0]);
   float yAbs = abs(v[1]);
   float zAbs = abs(v[2]);

   float s = 0;
   float t = 0;
   float a = 0;

   if (xAbs >= yAbs && xAbs >= zAbs)
   {
      a = xAbs;
      s = v[2];
      t = v[1];
   }
   else if (yAbs >= xAbs && yAbs >= zAbs)
   {
      a = yAbs;
      s = v[0];
      t = v[2];
   }
   else if (zAbs >= xAbs && zAbs >= yAbs)
   {
      a = zAbs;
      s = v[0];
      t = v[1];
   }
   else
   {
      // Should never reach this block
   }

   // Avoid zero divide
   st[0] = setRange(s / (a + 0.000001));
   st[1] = setRange(t / (a + 0.000001));

   return st;
}

vector triPlanarMapping(vector v, vector N)
{
   vector st;
   float ax = N[0] > 0.0 ? N[0] : -N[0];
   float ay = N[1] > 0.0 ? N[1] : -N[1];
   float az = N[2] > 0.0 ? N[2] : -N[2];

   if (ax > ay && ax > az)
   {
      st[0] = v[2];
      st[1] = v[1];
   }
   else if (ay > ax && ay > az)
   {
      st[0] = v[0];
      st[1] = v[2];
   }
   else
   {
      st[0] = v[0];
      st[1] = v[1];
   }

   st[0] = setRange(st[0]);
   st[1] = setRange(st[1]);

   return st;
}
vector concentricMapping(vector p)
{
  vector st;
  vector noisePoint = vector(0.01 * int(p[0]), 0.01 * int(p[1]), 0.01 * int(p[2]));
  float	temp = noise("perlin", noisePoint);
  st[1] = 0.5 + sin((p[0] - floor(p[0])) * 0.5) * sin((p[1] - floor(p[1])) * 0.5) * sin((p[2] - floor(p[2])) * 0.5);
  st[0] = temp;
  return st;
}
shader projection( int projType = 0, color transparency=0, float uAngle=0, float vAngle=0, color image = color(1,0,0), vector uvCoord=0, matrix placementMatrix = 0, output vector outUVCoord=0, output color outColor=0)
{
	float s = u;
	float t = v;
	if( isconnected(uvCoord))
	{
		s = uvCoord[0];
		t = uvCoord[1];
	}
	vector uvw;
	
	if( projType == 1) //planar
	{
		point PP = transform(placementMatrix, P);
		uvw = planarMapping(PP);
	}
	if( projType == 2) //spherical
	{
		point PP = transform(placementMatrix, P);
		uvw = sphericalMapping(PP, uAngle, vAngle);
	}
	if( projType == 3) //cylindrical
	{
		point PP = transform(placementMatrix, P);
		uvw = cylindricalMapping(PP, uAngle);
	}
	if( projType == 4) //ball
	{
		point PP = transform(placementMatrix, P);
		uvw = ballMapping(PP);
	}
	if( projType == 5) //cubic
	{
		point PP = transform(placementMatrix, P);
		uvw = cubicMapping(PP);
	}
	if( projType == 6) //triplanar
	{
		point PP = transform(placementMatrix, P);
		uvw = triPlanarMapping(PP, N);
	}
	if( projType == 7) //concentric
	{
		point PP = transform(placementMatrix, P);
		uvw = concentricMapping(PP);
	}
	outUVCoord = uvw;
	
	outColor = image;
}
